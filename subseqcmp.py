'measure similarity of sequences by comparing subsequence counts'
import math, json
import rng

# thoughts:
# - just counting whether a subsequence is present in another sequence approaches 1 for all randomizers that can generate any sequence (although perhaps that curve is interesting)
# - subsequence probability will be even across relabeling (for symmetrical randomizers), but will be grouped at different levels depending on the randomizer. the euclidean distance between two subseq frequency vectors gives you a measure of how similar they are.

pyrandom = rng.Python()

def run(randos):
    randos = list(randos)
    randos.sort(key=lambda r: r.__name__)

    seqPerRando = 1000
    seqLead = 100
    seqSize = 1000
    seqVar = 50  # 0--seqVar is added to both lead and size

    subsizes = list(range(2, 7))
    #subsizes = [2]
    #while 7 ** subsizes[-1] < seqPerRando * seqSize:
    #    subsizes.append(subsizes[-1] + 1)

    print('sequences = 2 x', seqPerRando, 'x', seqSize)
    print('subsizes =', ', '.join(map(str, subsizes)))
    print()

    print('counting subsequences...')
    counters = {}
    counters2 = {}  # for comparing randos to themselves
    getseqvar = lambda: pyrandom.randint(0, seqVar)
    for Rando in randos:
        print(Rando.__name__)
        counters[Rando] = SubSeqCounter(Rando, subsizes)
        counters2[Rando] = SubSeqCounter(Rando, subsizes)
        for _ in range(seqPerRando):
            counters[Rando].measure(seqLead + getseqvar(), seqSize + getseqvar())
            counters2[Rando].measure(seqLead + getseqvar(), seqSize + getseqvar())
    print()

    print('comparing...')
    lst = []
    for i, Rando in enumerate(randos):
        for Rando2 in randos[i:]:
            if Rando != Rando2:
                other = counters[Rando2]
            else:
                # in order to get a potentially non-zero distance, we have to compare with a separate SubSeqCounter (ssc.distance(ssc) is always 0)
                other = counters2[Rando2]

            d = counters[Rando].distance(other)
            # because d's values are 0..1, the max magnitude is sqrt(len(d) * 1**2)
            m = magnitude(d) / math.sqrt(len(d))
            lst.append((m, d, Rando.__name__, Rando2.__name__))
    lst.sort()

    for m, d, r1, r2 in lst:
        if r1 != r2:
            print(m, r1, r2)
    print()

    for m, d, r1, r2 in lst:
        if r1 == r2:
            print(m, r1, r2)
    print()

    with open('subseqcmp.json', 'w') as f:
        out = {}
        for m, d, r1, r2 in lst:
            out['%s %s' % (r1, r2)] = {'distances': d, 'magnitude': m}
        json.dump(out, f)

class SubSeqCounter:
    'counts subsequences of various sizes, in sequences generated by a randomizer'

    def __init__(self, Rando, subsizes):
        self.rando = Rando
        self.subs = {}
        for s in subsizes:
            self.subs[s] = {}
        self.maxcount = 0

    def measure(self, lead, size):
        '''
        count a sequence generated with the given parameters

        lead = number of pieces to burn off the beginning of the sequence
        size = length of sequence
        '''
        r = self.rando(pyrandom)

        historysize = max(self.subs.keys())
        for _ in range(lead - historysize):
            r.next()
        history = ''
        for _ in range(historysize):
            history += r.next()

        for _ in range(size):
            p = r.next()
            history = history[1:] + p
            for s in self.subs:
                subseq = history[-s:]
                self.subs[s][subseq] = self.subs[s].get(subseq, 0) + 1

        self.maxcount += size

    def distance(self, other):
        '''
        return {subsize: dist}

        dist is the distance between self and other's subs[subsize] interpreted as a vector
        dist is normalized (0..1)
        '''
        r = {}
        for s in set(self.subs) | set(other.subs):
            d = distance(self.subs.get(s, {}), other.subs.get(s, {}))
            # max d = distance({'x': maxcount}, {'y': maxcount})
            # max d = sqrt(2 * maxcount ** 2)
            r[s] = d / (math.sqrt(2) * self.maxcount)
        return r

    def saturation(self, other):
        '''
        return {subsize: saturation}

        saturation is the percent of self's subsequences that are also present in other, regardless of frequency
        saturation is normalized (0..1)
        '''
        r = {}
        for s in self.subs:
            count = 0
            for subseq in self.subs[s]:
                count += (subseq in other.subs[s])
            r[s] = count / len(self.subs[s])
        for s in other.subs:
            if s not in r:
                r[s] = 0
        return r

def distance(a, b):
    assert type(a) == dict and type(b) == dict
    total = 0
    for key in set(a.keys()) | set(b.keys()):
        total += (a.get(key, 0) - b.get(key, 0)) ** 2
    return math.sqrt(total)

def magnitude(v):
    if type(v) == dict:
        v = v.values()
    return math.sqrt(sum(a ** 2 for a in v))

if __name__ == '__main__':
    import randos

    #run(randos.byname.values())

    include = 'TGM Bag Constant FullRandom DeepBag Balanced WeightInfinite'.split()
    run([randos.byname[name] for name in include])
